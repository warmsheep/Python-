### GIL全局解释器锁

本质就是互斥锁

运行一个python文件，分为几步？产生了几个进程？

三步骤:
产生一个进程，分配内存空间

1.加载解释器功能

2.test.py加载到内存，python代码

3.执行，python是解释执行，CPython解释器


线程有一个target指向python代码，然后把python代码当做参数传给解释器。

线程1
线程2
线程3

假设三个线程可以同时运行，python还有个垃圾处理机制

所以这把锁是加在解释器的。

GIL.acquire()
GIL.release()

1.对CPython把同时运行的一个一个执行，这样保证了数据的安全
2.导致了对CPython解释器来说，每启动一个进程，统一进程的线程只有1个线程来运行。python没有运用到多核优势，只能开多进程，然后每个进程只有1个线程。
要运用多核优势，只能开启多进程。
3.垃圾回收线程是不是一直存在？不是的，CPython是定期会启动的
