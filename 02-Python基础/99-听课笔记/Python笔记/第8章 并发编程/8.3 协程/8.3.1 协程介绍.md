## 协程介绍

问题:假设现在有5个任务，需要实现并发的效果，要么开启5个进程，要么开启5个线程；

问题:如果想把5个任务放到一个线程中去，能不能实现并发的效果？

单线程不能实现并行，但是可以实现并发。但是这种并发是程序员控制的。

单线程需要实现并发就是协程要干的事儿。

并发实现本质是切换＋保证状态

协程就是要找到一种解决方案，让程序员从应用程序角度，能实现运行一个任务切换到另一个任务，并且保证状态。

### 协程实现

##### 1.基于yield实现单线程下的并发

```python
import time

def producer():
    g=consumer()#先拿到生成器
    next(g)#初始化表达式
    for i in range(10000):
        g.send(i)


def consumer():
    while True:
        res=yield

star_time=time.time()
producer()
end_time=time.time()
print(end_time-star_time)
```

输出结果

```python
0.0015921592712402344
```
操作系统会切换的两种情况？

1.遇到IO(这种切换会提高效率)
2.没有IO，也会切换，保证CPU雨露均沾

现在是遇到计算切，反而会降低效率，与下面的串行执行进行比较。

单线程实现并发的目标:
实现IO才切


##### 2.串行执行非IO的操作

```python
import time
def producer():
    res=[]
    for i in range(10000):
        res.append(i)
    return res


def consumer(res):
    pass

star_time=time.time()
res=producer()
consumer(res)
end_time=time.time()
print(end_time-star_time)
```

输出结果

```python
0.0015878677368164062
```


单线程下面有5个任务，任务都是IO密集型，一个都是1，2，3，4，5，串行执行为1+2+3+4+5，如果并行执行，只需要5s。

如果能找到解决方案，能能够检测单线程下面任务的IO行为，实现遇到IO行为才切换，这就实现了效果。

线程里面干的事儿操作系统管不着，自己线程里面，代码级别实现了自己的任务遇到IO了，自己控制到让任务立马切到这个线程的另外一个任务去执行，这样对操作系统看来，骗过了操作系统，始终处于计算，但是有个问题，程序可以让单线程的IO降到最低，意味着自己的线程给伪装了，操作系统看来这个线程整体就是阻塞态降低，就绪状态增多，保证了程序的高效。

但是单线程不可能吧阻塞减没。

这不叫欺骗，这叫自己真的把IO行为降低了。

yield也叫线程，但是我们想实现的是遇到IO才切换的效果。


### 总结

协程:单线程下面的并发，用户态的轻量级线程，用户自己进行调度。



协程修改共享数据不需加锁，因为协程不是同时执行，是一个一个执行，没必要加锁。

yield不能实现遇到IO就切。
