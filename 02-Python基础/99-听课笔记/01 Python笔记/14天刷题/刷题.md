## 一、求和:二维数组的积-二维数组最小公倍数

### 题目level
* 7kyu

### 题目描述

* 在这个kata中，您需要创建一个函数，该函数采用非负整数对的二维数组/列表，并返回所有“保存”的总和，您可以获得每个数字的LCM与其简单产品的比较。

* For example, if you are given:
```
[[15,18], [4,5], [12,60]]
```
* 每个二维数组的乘积为:
```
[270, 20, 720]
```
* 每个二维数组的最小公倍数为:
```
[90, 20, 60]
```
* 最终结果为:
```
(270-90)+(20-20)+(720-60)==840
```
### 解题思路
* 1.这道题的题意很清楚:
```
SUM(二维数组的积-二维数组的最小公倍数)
```
* 2.第一步先考虑求二维数组的积
* 3.求二维数组的最小公倍数(本题难点)


### 解题代码
* 我的代码
```python
def gcd(m,n):
    if not n:
        return m
    else:
        return gcd(n, m%n)

def LCM(m, n):
    if m*n == 0:
        return 0
    return int(m*n/gcd(m, n))

def sum_differences_between_products_and_LCMs(pairs):
    result=0
    for i in pairs:
        result+=(i[0]*i[1]-LCM(i[0], i[1]))
    return result
```

* fork解答

```python
def gcd(a,b):
    min_val, max_val = min(a,b), max(a,b)
    while min_val:
        min_val, max_val = max_val % min_val, min_val
    return max_val

def lcm(a,b):
    return (a*b) / gcd(a,b)

def sum_differences_between_products_and_LCMs(pairs):
    return sum(0 if not a*b else a*b - lcm(a,b) for a,b in pairs)
```


### 题目反思
* 1.解题难点在于如何求最小公倍数
##### 如何求最小公倍数？
* 公式
```
最小公倍数 = 乘积 / 最大公约数
```
这个问题转化为如何求最大公约数。

##### 如何求最大公约数(自己总结)

*网上经验帖总结*

* 1. 如果两者中有一个数字为0，则另一个数字为最大公约数。
* 2. 如果两个数字都不为0，则两者相除取余数，并调换参数位置，余数再来和另外一个数字求公倍数，最终获得最大公约数。(这里用到递归的方法，可以试着写几个例子去验证一下)

*网上经验贴代码如下*

```python
def gcd(m,n):

    if not n:
        return m
    else:
        return gcd(n, m%n)
```

*fork解法*

* 1.先找到两个数的最大值和最小值
* 2.最小值不为0的情况下:
  * 最大值%最小值 取余数，将余数重新赋值给最小值，之前的最小值成为最大值
```
(这里是为啥？因为a/b的余数，是永远不可能大于等于b的，所以最大值除最小值的余数肯定小于最小值，所以余数应该成为新的最小值)
```
* 3.当余数为0的时候，说明被除的整数为两个数字的最大公约数。

```python
def gcd(a,b):
    min_val, max_val = min(a,b), max(a,b)
    while min_val:
        min_val, max_val = max_val % min_val, min_val
    return max_val
```



## 二、Most improved - Puzzles #4

### 题目level
* 6kyu

### 题目描述
* 在某个科目或某个课程中进行评分时，评分最高的是最重要的，但哪些方面的评分最高？作为一名计算机科学教师，您希望创建一个计算最优化学生的函数，并将它们排列在列表中。

**任务**
* 你的任务是强制calculateImproved函数返回一个按百分比最大改进排序的数组。

**输入**
* 您将收到的输入将是一组学生，学生将是一个包含名称和标记数组的对象（按照成绩排列），标记将不超过100，但是如果测试的学生可以标记为空没有尝试（把它当作0）
学生对象示例：
```python
{name:'Henry, Johns','marks':[25,50]}
{name:'Alex, Bug','marks':[None,100]}
{name:'Blach, Joe','marks':[0,100]}
{name:'Kjax, Cue','marks':[0,None]}
{name:'Cod with','marks':[90,None]}
```

**产量**
* 预期的输出将是一个类似于学生对象的对象数组，其中包含名称和总计提高百分比，用于计算总体提高百分比。输出数组必须按大多数改进进行排序（舍入计算的改进）如果改进中存在联系，则按名称排序（大写在小写之前）。

返回对象示例：
```python
{name:'Henry, Johns',"improvement":100}
{name:'Alex, Bug',"improvement":0}
{name:'Blach, Joe',"improvement":0}
{name:'Kjax, Cue',"improvement":0}
{name:'Cod with',"improvement":-100.0}
```

**预装**
* Student类已经预装了接受两个参数的构造函数名称和标记，这些参数应该是数字数组。


### 题目思路
* 1.先将所有情况讨论(for i in studnets)，新增improvement键值，并移除marks键值对:
  * 1.1 首项不为0或None，尾项不为None
  * 1.2 首项不为0或None，尾项为None
  * 1.3 首项为0或None
* 2.针对新列表进行排序，排序要求为先按照分数降序，再按照姓名升序。
* 注意:在python3.6中对字典新增的值一般都显示在最后一对k-v中，但是在python2.7中新增的值不一定是显示在最后一对k-v中，所以这点记住，对本体题来说显示的时候其实这个不是很重要，但是对于有的题目可能就需要注意一下。

### 题目代码
* 我的代码
```python
from __future__ import division
def calculate_improved(students):
    for i in students:
        if i["marks"][0]:
            if not i["marks"][-1] ==None:
                i["improvement"]=round(float(i["marks"][-1]/i["marks"][0]-1)*100)
            else:
                i["improvement"]=-100.0
        else:
            i["improvement"] = 0
        i.pop("marks")
    return sorted(students,key=lambda x:(-x.get("improvement"),x["name"]))
```

* 优秀代码
```python
def calculate_improved(students):
    students = ({
        "name"       : s["name"],
        "improvement": round(
            100.0 * (s["marks"][-1] or 0) / (s["marks"][0] or 0) - 100.0)
            if s["marks"][0] else 0
    } for s in students)
    return sorted(students, key=lambda s: (-s["improvement"], s["name"]))
```
### 题目反思
##### 我的代码反思
* 1.个人觉得这个题的描述太过省略了，本例题中的总结中我把题目描述所有的情况都写进去了，但是kata的描述只有第一个，我需要每次试错才能知道情况，所以针对这个题目我觉得题目描述太不明朗，建议大家做个题先来看看我的描述，少走点弯路。

* 2.另外一个就是版本问题，题目中只能用python2.7，而我一直用的python3.6版本，版本不同会导致除法运算的结果不同:

  * 除法运算，关于这两个除法运算的区别如下:

    python2.7
    ```python
    >>> 1/3
    0
    >>> 28/14
    2
    >>> 28/15
    1
    ```
    python3.6
    ```python
    >>> 1/3
    0.3333333333333333
    >>> 28/14
    2.0
    >>> 28/15
    1.8666666666666667
    ```
    解决方法一:引用模块

    ```python
    from __future__ import division
    ```

    ```python
    >>> from __future__ import division
    >>> 1/3
    0.3333333333333333
    ```
    解决方法二:将数字float后再进行除法运算
    ```python
    >>> float(2)/float(4)
    0.5
    >>> float(2)/float(2220)
    0.0009009009009009009
    ```

* 3.针对一个列表中如何进行多条件排序，这个会在新学知识点有所总结。

##### 优秀代码总结
**思路**
看了一下排序和我的代码没啥区别，只是计算improvement的差别，其思路为:

* 1.1 计算原始"improvement"
```
Inc=(100*(最新的值/起始值)-100) if 起始值有意义(排除了None和O的情况) else 0
```
* 1.2 排除可能存在的错误:

  * 最新的值可能出现None导致计算类型出错，所以避免这种情况的出现，使用or来解决这种错误(最新值 or 0)，同样也对起始值这样避免问题。
```
Inc=(100*(最新的值 or 0）/(起始值 or 0)-100) if 起始值有意义 else 0
```
* 1.4 round(Inc) 对增幅值保留一位小数

```
针对优秀代码有个小小可以改正的点:
if s["marks"][0]已经排除了为0和None的情况，
所以它作为分母始终是有意义的，不需要在写成(s["marks"][0] or 0)，
直接写成 s["marks"][0]
```
**改写后的代码如下:**

```python
def calculate_improved(students):
    students = ({
        "name": s["name"],
        "improvement": round(
            100.0 * (s["marks"][-1] or 0) / s["marks"][0] - 100.0)
            if s["marks"][0] else 0
    } for s in students)
    return sorted(students, key=lambda s: (-s["improvement"], s["name"]))
```


##### 新学知识点

* 1.针对2.7版本的如果需要实现3.6的除法效果，添加模块最省事儿

```python
from __future__ import division
```
**排序**
* 2.1 单条件排序
```
方法有两种，
a. 笔记中的operator模块下的getteritem,这里就不详细说了，
b. lambda函数
```
```python
#针对固定位置的值，升序
sorted(iterable,key=lambda x:x[index])
#针对某个键的值，升序
sorted(iterable,key=lambda x:x[key])
```

```python
s=[ ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),]
sorted(s, key=lambda student: student[2])
#输出结果
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
```

```python
s_dic=[{"name":"alex","age":18},{"name":"peqi","age":20},{"name":"egon","age":28}]
sorted(s_dic,key=lambda x:x.get("age"))
#输出结果
[{'name': 'alex', 'age': 18}, {'name': 'peqi', 'age': 20}, {'name': 'egon', 'age': 28}]
```

* 2.2 多条件排序

```python
#针对固定位置的值，升序
sorted(iterable,key=lambda x:(x[index1],x[index2]))
#针对某个键的值，依次按照升序排列
sorted(iterable,key=lambda x:(x[key1],x[key2]...))
```
* 先对年龄升序，如果年龄相同对名字升序排列。

```python
s_dic=[{"name":"alex","age":18},{"name":"peqi","age":20},{"name":"egon","age":20}]
sorted(s_dic,key=lambda x:(x["age"],x["name"]))
#输出结果
[{'name': 'alex', 'age': 18}, {'name': 'egon', 'age': 20}, {'name': 'peqi', 'age': 20}]
```

* **问题1:** 如果我要对一个升序一个降序排列呢？比如先对针对上个例子年龄降序排列，年龄相同名字再升序排列？

* **解决1:** 直接用多条件排序都是升序排列，所以针对年龄来说降序排列也就是对年龄的负数升序排列，转换过来就ok了，在x["age"]前面加个符号:

```python
s_dic=[{"name":"alex","age":18},{"name":"peqi","age":20},{"name":"egon","age":20}]
sorted(s_dic,key=lambda x:(-x["age"],x["name"]))
#输出结果
[{'name': 'egon', 'age': 20}, {'name': 'peqi', 'age': 20}, {'name': 'alex', 'age': 18}]
```

* **问题2:** 如果我要对上例题中的年龄升序排列，但是名字降序排列呢？

* **解决2:** 针对这个问题，将问题1反转过来，就OK了

```python
s_dic=[{"name":"alex","age":18},{"name":"peqi","age":20},{"name":"egon","age":20}]
sorted(s_dic,key=lambda x:(-x["age"],x["name"]),reverse=True)
#输出结果
[{'name': 'alex', 'age': 18}, {'name': 'peqi', 'age': 20}, {'name': 'egon', 'age': 20}]
```

## 三、Product of consecutive Fib numbers
### 题目level
* 5kyu

### 题目描述
* F（m）是最小的一个，例如F（m）* F（m + 1）> prod。
* 例子
```python
productFib（714）#应该返回[21，34，true]
#由于F（8）= 21，F（9）= 34和714 = 21 * 34
productFib（800)#应该返回[34，55，false]，
#F（8）= 21，F（9）= 34，F（10）= 55和21 * 34 <800 <34 * 55
```
* 注意：这里没有用，但我们可以告诉如何选择数字n到哪去：我们可以使用“黄金比例”phi，它是（1 + sqrt（5））/ 2，知道F（n）是渐近的 到：phi ^ n / sqrt（5）。 这给n提供了一个可能的上限。


### 题目思路
* 1.先创造fib函数，定义fib，传入参数n，返回离n最近的b，以及b前面的a组成的列表
```
运用一个定理:a*b=c**2,a != b，那么a,b中一定有一个数大于c，一个数小于c
```
* 2.对主函数的参数prod进行向下取开方数，将这个数传入fib中，得到列表m
* 3.对m中的元素相乘，进行判断:
  * 3.1 如果乘积==prod，则m中追加True
  * 3.2 如果乘积 > prod，则m中追加False
  * 3.3 如果乘积 < prod，则m的b应该再往后取一位数字，解决办法:先追加sum(m)，再追加一个False，然后取值应该从第2位元素到最后一位元素。



### 题目代码
* 我的代码
```python
import math
def fib(n):
    a, b = 0, 1
    while b <= n:
        a, b = b, a + b
    return [a,b]
def productFib(prod):
    s=math.floor(math.sqrt(prod))
    m=fib(s)
    if m[0]*m[1]==prod:
        m.append(True)
        return m

    elif m[0]*m[1] < prod:
        m.append(sum(m))
        m.append(False)
        return m[1:]
    else:
        m.append(False)
        return m
```

* 优秀代码

```python
def productFib(prod):
    a, b = 0, 1
    while prod > a * b:
        a, b = b, a + b
    return [a, b, prod == a * b]
```

### 题目反思
##### 我的代码反思
* 1.反思结果:我的代码对条件写的太多了，导致了代码数量很长很长
* 2.其实返回一个列表我也不是很满意，但是为了后面的追加，我才用的，继续努力吧，第一个5kyu的题目。

##### 优秀代码总结
**思路**
* 1.对fib函数进行一个条件循环，循环条件为:prod>a\*b，这样避免了条件讨论a*b和prod的比较，因为当a\*b=prod时候，循环结束了。
* 2.然后返回一个列表，列表中有一个bool值，条件为prod==a*b



## 五、FIXME: Hello
### 题目level
* 6kyu

### 题目描述

* 提供的代码有一个方法hello，它应该只显示那些已经明确设置的属性。 此外，它应该按照它们设定的顺序来说。
* 注意:有3个属性:名称、年龄、性别（'M'或'F'）

* 当多次分配相同的属性时，hello方法只显示一次。 如果发生这种情况，顺序取决于该属性的第一次赋值，但该值来自最后一次赋值。

* 举例
```python
Hello.
Hello. My name is Bob. I am 27. I am male.
Hello. I am 27. I am male. My name is Bob.
Hello. My name is Alice. I am female.
Hello. My name is Batman.
```


### 题目思路
* 1.先属性的名称按照属性赋值的顺序依次添加到一个列表中。
* 2.将属性名称-对应的句子按照k-v的模式保存在字典中
* 3.根据列表的顺序从字典中取值，并拼接起来。

### 题目代码
* 我的代码

```python
class Dinglemouse(object):

    def __init__(self):
        self.name = None
        self.sex = None
        self.age = None
        self.list=["hello"]

    def setAge(self, age):
        self.age = age
        if "age" not in self.list:
            self.list.append("age")

        return self

    def setSex(self, sex):
        self.sex = sex
        if "sex" not in self.list:
            self.list.append("sex")
        return self

    def setName(self, name):
        self.name = name
        if "name" not in self.list:
            self.list.append("name")
        return self

    def hello(self):

        dict={
            "hello":"Hello.",
            "name":"My name is {}.".format(self.name),
            "age":"I am {}.".format(self.age),
            "sex":"I am {}.".format("male" if self.sex == "M" else "female")
        }
        return " ".join(dict[x] for x in self.list)
```

* 优秀代码

```python
class Dinglemouse(object):

    def __init__(self):
        self.dct = {}

    def setAge(self, age):
        self.dct['age'] = f'I am {age}.'
        return self

    def setSex(self, sex):
        self.dct['sex'] = f'I am {"male" if sex=="M" else "female"}.'
        return self

    def setName(self, name):
        self.dct['name'] = f'My name is {name}.'
        return self

    def hello(self):
        return ' '.join(['Hello.'] + list(self.dct.values()))
```
### 题目反思
##### 我的代码反思
* 1.通过列表来存储属性赋值的顺序，并不是一个好的办法，这会浪费内存空间。

##### 优秀代码总结
**思路**
* 1.将属性赋值的时候，直接将句子保存在字典里，key:属性名称，value:句子
* 2.针对字典的所有values值通过' '拼接起来，并在开头添加一个'Hello. '

**新学知识点**
* 1.python3.6中的新特性，f表示format的意思:
```python
self.dct['age'] = f'I am {age}.'
#等价于
self.dct['age'] = 'I am {age}.'format(age=age)
```

* 2.字典虽然是无序的，但是如果一开始为空字典，往里面新加key-value，k的显示顺序是k第一次被添加进去的顺序，即使后面对之前的k重新赋值，k的位置依然不变，所以我的列表排序根本就是没有必要的，直接用一个字典就可以解决所有的问题。

* 举个例子来证明知识点2
```python
dic={}
dic["b"]=21
dic["a"]=11
dic["c"]=10
print(dic)
#输出
{'b': 21, 'a': 11, 'c': 10}
```
```python
dic={}
dic["b"]=21
dic["a"]=11
dic["c"]=10
dic["a"]=100
dic["d"]=101
print(dic)
#输出
{'b': 21, 'a': 100, 'c': 10, 'd': 101}
```python
