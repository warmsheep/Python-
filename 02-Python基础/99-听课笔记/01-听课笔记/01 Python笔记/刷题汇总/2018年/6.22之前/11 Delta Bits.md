## Delta Bits
### 题目level
* 7kyu

### 题目描述
* 编写函数以确定将整数A转换为整数B所需的位数（其中A和B> = 0,A和B没有上限)

* 举例

您可以通过翻转第4位和第0位来更改31到14：

```python
31  0 0 0 1 1 1 1 1
14  0 0 0 0 1 1 1 0
---  ---------------
bit  7 6 5 4 3 2 1 0
```

Thus 31 and 14 should return 2.


### 题目思路
* 1.先将数字转为二进制数字，然后去掉左边的"0b"
* 2.得到两位二进制的最大长度n,将a,b分别填充到n位。
* 3.针对长度相同的每一位二进制数字比较，如果不相同，则计数+1，返回计数


### 题目代码
* 我的代码
```python
def convert_bits(a, b):
    b1=bin(b).lstrip("0b")
    a1=bin(a).lstrip("0b")
    n=max(len(a1),len(b1))
    a2,b2=a1.zfill(n),b1.zfill(n)
    count=0
    for i in range(n):
        if not b2[i]==a2[i]:
            count+=1
    return count
```

* 优秀代码
```python
def convert_bits(a, b):
    return str(bin(a ^ b)).count('1')
```

### 题目反思
##### 我的代码反思
* 1.针对去掉二进制前面的"0b"是为了方便填充，取到最大长度值，也是为了时两个字符串长度一致，方便比较。
* 2.我的代码还是很冗余的，而且比较浪费空间，因为有要循环迭代3次。

##### 优秀代码总结
* 1.突破点:a,b的1的个数不对，其实就是a-b后的值。
* 2.运用方法，运用了Python位运算操作符^，然后把异或运算后的1进行计数，就得到答案了，关于什么是异或运算，详情看下面。

**新学知识点:异或运算^**
* 二进制异或(^)。按位的运算，都按位的运算，都是把参加运算的数的二进制形式进行运算。
* 运算规则：
  ```python
  0^0=0；
  0^1=1；
  1^0=1；
  1^1=0；
